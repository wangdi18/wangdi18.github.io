title: Git简单使用（1）--本地仓库
author: 王迪
tags:
  - Git
categories: []
date: 2020-03-01 19:06:00
---
本篇主要以本地仓库使用为主。
## 提交 git commit
Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！

Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。

Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因。
<!-- more -->

## 分支 gitbranch 
Git 的分支也非常轻量。它们只是简单地指向某个提交纪录。

在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”
## 分支与合并
### 1.git merge
在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”
```
git branch bugFix 	//创建bugFix分支
git checkout bugFix		//切换到bugFix分支
git commit				//在bugFix分支进行提交
git checkout master		//切换到master
git commit				//在master进行提交
git merge bugFix		//将bugFix合并到master
```
### 2.git rebase
Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。

Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。
```
git branch bugFix		//创建bugFix分支
git checkout  bugFix	//切换到bugFix分支
git commit				//在bugFix分支进行提交
git checkout master		//切换到master
git commit				//在master进行提交
git checkout bugFix		//切换到bugFix分支
git rebase master		//将rebase分支合并到master
```
## 在提交树上移动

我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。HEAD 随着提交向前移动。如果想看 HEAD 指向，可以通过 cat .git/HEAD 查看， 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向。
 
 ### 分离的 HEAD
 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。（即通过提交记录哈希值来在Git中实现移动）
 

 
 ## 相对引用
 
 通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，你就不得不用 git log 来查查看提交记录的哈希值。
 
 通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。
 - 使用 ^ 向上移动 1 个提交记录
 
 `git checkout master` HEAD 指向master的上一个节点
 - 使用 ~num 向上移动多个提交记录，如 ~3（上标~），
 该操作符后面可以跟一个数字（可选，不跟数字时与 ^ 相同，向上移动一次），指定向上移动多少次。
 
 ### 强制修改分支位置
 
 用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如:
 
 `git branch -f master HEAD~3`
 
 上面的命令会将 master 分支强制指向 HEAD 的第 3 级父提交。
 
 ## 撤销变更
 
 在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们关注后者。
 ### 1.git reset
 git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。
 
 `git reset HEAD~1`
 
 Git将分支向上移动一层（移动到C1），我们的本地代码库根本就不知道未移动前（C2）这个提交了。（在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。）
 
 ### 2.git revert
 虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的。为了撤销更改并分享给别人，我们需要使用 git revert。
 
 `git revert HEAD`
 
 在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2' 引入了更改 —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2' 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享了。
 
 ## 整理提交记录
 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式。
 ### 1.git cherry-pick
 命令格式为：
 
 `git cherry-pick <提交号>...`
 
 如果你想将一些提交复制到当前所在的位置（HEAD）下面的话， cherry-pick 是最直接的方式了。
 
	`git cherry-pick C3 C4 C7`

	将C3、C4、C7复制到当前分支下
    ### 2.交互式的 rebase
    当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了
    交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i，如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。
    
  当 rebase UI界面打开时, 你能做3件事:
  - 调整提交记录的顺序（通过鼠标拖放来完成）
  - 删除你不想要的提交（通过切换 pick 的状态来完成，关闭就意味着你不想要这个提交记录）
  - 合并提交。
  
  ## 本地栈式提交
    来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！最后就差把 bugFix 分支里的工作合并回 master 分支了。你可以选择通过 fast-forward 快速合并到 master 分支上，但这样的话 master 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……
    
    实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用`git rebase -i` 或者`git cherry-pick`来达到目的。
    
    ## 提交的技巧1
    接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。

	此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 newImage 中图片的分辨率，尽管那个提交记录并不是最新的了。
    
    我们可以通过下面的方法来克服困难：
    - 先用 `git rebase -i` 将提交重新排序，然后把我们想要修改的提交记录挪到最前
    - 然后用 `commit --amend` 来进行一些小修改
    - 接着再用 `git rebase -i` 来将他们调回原来的顺序
    - 最后我们把 master 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！
    
   ## 提交的技巧2
    正如我们在前面所见到的，我们可以使用 rebase -i 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 --amend 修改它，然后把它们重新排成我们想要的顺序。

	但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 git cherry-pick 是怎么做的吧。
    
    要在心里牢记 cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。
    
    ## Git Tags
    相信通过前面的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。

	你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？
    
    当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。

	更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。
    
    `git tag v1 C1`
    
    我们将这个标签命名为 v1，并且明确地让它指向提交记录 C1，如果你不指定提交记录，Git 会用 HEAD 所指向的位置。
    
    ## Git Describe
    由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是 git describe
    
    Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。
    
    git describe 的语法是：
    
    `git describe <ref>`
    
    ref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。

	它输出的结果是这样的：

	tag_numCommits_g(hash)

	tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。

	当 ref 提交记录上有某个标签时，则只输出标签名称.
    
    `git tag v2 C3`
    
    git describe master 会输出：v1_2_gC2，git describe side 会输出：v2_1_gC4